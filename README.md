# Книга контактів

Напиши застосунок зберігання контактів телефонної книги.

## Крок 1

Застосунок повинен складатися з форми і списку контактів. На поточному кроці
реалізуй додавання імені контакту та відображення списку контактів. Застосунок
не повинен зберігати контакти між різними сесіями (оновлення сторінки).

Використовуйте цю розмітку інпуту для імені контакту.

```html
<input type="text" name="name" required />
```

Стан, що зберігається в батьківському компоненті **`<App>`**, обов'язково
повинен бути наступного вигляду, додавати нові властивості не можна.

```jsx
state = {
  contacts: [],
  name: '',
};
```

Кожен контакт повинен бути об'єктом з властивостями `name` та `id`. Для
генерації ідентифікаторів використовуй будь-який відповідний пакет, наприклад
**nanoid**. Після завершення цього кроку, застосунок повинен виглядати приблизно
так.

## Крок 2

Розшир функціонал застосунку, дозволивши користувачам додавати номери телефонів.
Для цього додай <input type="tel"> у форму і властивість для зберігання його
значення в стані.

```jsx
state = {
  contacts: [],
  name: '',
  number: '',
};
```

Використовуй цю розмітку інпуту для номеру контакту.

```html
<input type="tel" name="number" required />
```

Після завершення цього кроку, застосунок повинен виглядати приблизно так.

## Крок 3

Додай поле пошуку, яке можна використовувати для фільтрації списку контактів за
ім'ям.

Поле пошуку – це інпут без форми, значення якого записується у стан
(контрольований елемент). Логіка фільтрації повинна бути нечутливою до регістру.

```jsx
state = {
  contacts: [],
  filter: '',
  name: '',
  number: '',
};
```

Коли ми працюємо над новим функціоналом, буває зручно жорстко закодувати деякі
дані у стан. Це позбавить необхідності вручну вводити дані в інтерфейсі для
тестування роботи нового функціоналу. Наприклад, можна використовувати такий
початковий стан.

```jsx
state = {
  contacts: [
    { id: 'id-1', name: 'Rosie Simpson', number: '459-12-56' },
    { id: 'id-2', name: 'Hermione Kline', number: '443-89-12' },
    { id: 'id-3', name: 'Eden Clements', number: '645-17-79' },
    { id: 'id-4', name: 'Annie Copeland', number: '227-91-26' },
  ],
  filter: '',
  name: '',
  number: '',
};
```

## Крок 4

Якщо твій застосунок реалізований в одному компоненті `<App>`, виконай
рефакторинг, виділивши відповідні частини в окремі компоненти. У стані
кореневого компонента <App> залишаться тільки властивості contacts і filter.

```jsx
state = {
  contacts: [],
  filter: '',
};
```

Достатньо виділити чотири компоненти: форма додавання контактів, список
контактів, елемент списку контактів та фільтр пошуку.

Після рефакторингу кореневий компонент застосунку виглядатиме так.

```html
<div>
  <h1>Phonebook</h1>
  <ContactForm ... />

  <h2>Contacts</h2>
  <Filter ... />
  <ContactList ... />
</div>
```

## Крок 5

Заборони користувачеві можливість додавати контакти, імена яких вже присутні у
телефонній книзі. При спробі виконати таку дію виведи alert із попередженням.

## Крок 6

Розшир функціонал застосунку, дозволивши користувачеві видаляти раніше збережені
контакти.

# Настанови ментора

Основний стейт повинен бути в **`Арр`**:

```jsx
state = {
  contacts: [],
  filter: '',
};
```

Для перевірки існуючого контакту використовуйте `патерн "раннє повернення"`:

```jsx
if (isExist) {
  alert(`${name} is already in contacts.`);
  return;
}
```

В компонент **ContactsList** передаємо два props:

- список відфільтрованих контактів;
- посилання на функцію для видалення контакту.

Можете використати ці патерни, замість тих, що запропоновані в ТЗ до ДЗ щоб в
консолі не було помилок:

```jsx
pattern = "^[a-zA-Zа-яА-Я]+(([' \\-][a-zA-Zа-яА-Я ])?[a-zA-Zа-яА-Я]*)*$";
pattern =
  '\\+?\\d{1,4}?[ .\\-\\s]?\\(?\\d{1,3}?\\)?[ .\\-\\s]?\\d{1,4}[ .\\-\\s]?\\d{1,4}[ .\\-\\s]?\\d{1,9}';
```

# Виконання

Для генерації унікальних ідентифікаторів за допомогою пакету `nanoid` спершу
потрібно встановити пакет `nanoid` у проекті:

```jsx
npm install nanoid
```

Приклад, як можна згенерувати ідентифікатори для об'єктів:

```jsx
import { nanoid } from 'nanoid';
// const { nanoid } = require('nanoid'); - стара версія імпорту

const id1 = nanoid();
const id2 = nanoid();
const id3 = nanoid();
const id4 = nanoid();

console.log(id1, id2, id3, id4);
```

У цьому прикладі використовуємо `nanoid()` для генерації унікальних
ідентифікаторів `(id1, id2, id3, id4)`.

## Крок 1

- Створюємо компоненти **`ContactList`**, який відображає список контактів
- та батьківський компонент **`App`** для керування станом додатку і додавання
  нових контактів. Контакти зберігаються в стейт (в стані) **`App`** у вигляді
  масиву об'єктів з властивостями `name` і `id`.

- Для генерації ідентифікаторів контактів використовуємо бібліотеку `nanoid`.
